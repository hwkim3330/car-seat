<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>KETI — Seat Analysis Dashboard</title>
<script src="libs/three.min.js"></script>
<script src="libs/OrbitControls.js"></script>
<script src="libs/GLTFLoader.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#f0f2f5;
  --surface:rgba(255,255,255,.95);
  --card:#ffffff;
  --border:rgba(0,0,0,.08);
  --text:#1a1a2e;
  --text2:#5a6070;
  --text3:#9a9fb0;
  --accent:#2563eb;
  --dim:rgba(37,99,235,.08);
}
body{
  font-family:'Inter',-apple-system,BlinkMacSystemFont,sans-serif;
  background:var(--bg);
  color:var(--text);
  overflow:hidden;
  -webkit-font-smoothing:antialiased;
}
.app{display:flex;flex-direction:column;height:100vh}

/* ── HEADER ── */
.hdr{
  height:52px;flex-shrink:0;
  background:var(--card);
  border-bottom:1px solid var(--border);
  display:flex;align-items:center;
  padding:0 20px;z-index:10;
}
.hdr-left{display:flex;align-items:center;gap:10px;min-width:220px}
.hdr-left img{height:22px;opacity:.85}
.hdr-left h1{font-size:14px;font-weight:700;letter-spacing:-.3px;color:var(--text)}
.hdr-tag{
  font-size:8px;font-weight:700;color:var(--accent);
  background:var(--dim);padding:2px 6px;border-radius:4px;
  letter-spacing:.5px;margin-left:4px;
}
.hdr-center{flex:1;display:flex;align-items:center;justify-content:center;gap:5px}
.hdr-right{display:flex;align-items:center;gap:8px;min-width:220px;justify-content:flex-end}

.pb{
  padding:6px 12px;border-radius:6px;border:none;
  background:rgba(0,0,0,.04);color:var(--text2);
  font-size:10px;font-weight:600;cursor:pointer;
  font-family:inherit;transition:all .15s;
}
.pb:hover{background:rgba(0,0,0,.08)}
.pb.on{background:var(--accent);color:white}

.toggle-btn{
  padding:5px 10px;border-radius:6px;
  border:1px solid var(--border);background:var(--card);
  color:var(--text2);font-size:10px;font-weight:600;
  cursor:pointer;font-family:inherit;transition:all .15s;
  display:flex;align-items:center;gap:5px;
}
.toggle-btn.on{background:var(--accent);color:white;border-color:var(--accent)}

.export-btn{
  padding:5px 12px;border-radius:6px;
  border:1px solid var(--border);background:var(--card);
  color:var(--text);font-size:10px;font-weight:600;
  cursor:pointer;font-family:inherit;transition:all .15s;
  display:flex;align-items:center;gap:5px;
}
.export-btn:hover{background:var(--bg)}

/* ── CONTENT ── */
.content{flex:1;display:flex;overflow:hidden}

/* ── LEFT PANEL ── */
.lp{
  width:280px;flex-shrink:0;
  overflow-y:auto;background:var(--surface);
  border-right:1px solid var(--border);
}
.lp::-webkit-scrollbar{width:3px}
.lp::-webkit-scrollbar-thumb{background:rgba(0,0,0,.1);border-radius:2px}

.lp-hdr{
  padding:10px 12px 8px;
  border-bottom:1px solid var(--border);
  display:flex;align-items:center;justify-content:space-between;
}
.lp-hdr-title{font-size:10px;font-weight:700;color:var(--text3);text-transform:uppercase;letter-spacing:.7px}
.lp-hdr-count{font-size:9px;color:var(--text3);font-weight:500}

.seat-card{
  background:var(--card);border-radius:8px;
  margin:6px 8px;box-shadow:0 1px 3px rgba(0,0,0,.08);
  border-left:3px solid transparent;overflow:hidden;
  transition:border-color .15s;
}
.seat-card.sel{border-left-color:var(--accent)}

.card-hdr{
  display:flex;align-items:center;justify-content:space-between;
  padding:8px 10px;cursor:pointer;user-select:none;
  transition:background .1s;
}
.card-hdr:hover{background:rgba(0,0,0,.02)}

.card-hdr-left{display:flex;align-items:center;gap:8px}
.card-dot{width:10px;height:10px;border-radius:50%;flex-shrink:0}
.card-name{font-size:12px;font-weight:600;color:var(--text)}
.card-wt{font-size:10px;color:var(--text2);font-weight:500;margin-left:4px}
.card-chevron{font-size:9px;color:var(--text3);transition:transform .2s}
.card-chevron.collapsed{transform:rotate(-90deg)}

.card-body{padding:0 10px 8px;display:block}
.card-body.collapsed{display:none}

.card-divider{
  height:1px;background:var(--border);
  margin:6px 0;
}

.wt-row{display:flex;align-items:center;gap:6px;margin-bottom:2px}
.wt-label{font-size:9px;color:var(--text3);font-weight:600;text-transform:uppercase;letter-spacing:.4px}
.wt-val{
  font-size:9px;color:var(--text3);font-weight:600;
  min-width:32px;text-align:right;font-variant-numeric:tabular-nums;
}
.wt-slider{flex:1;margin:0 2px}

.slider-sec-title{
  font-size:8px;font-weight:700;color:var(--text3);
  text-transform:uppercase;letter-spacing:.5px;
  margin:6px 0 4px;
}

.mini-ctrl{display:flex;align-items:center;gap:4px;margin-bottom:4px}
.mini-ctrl:last-child{margin-bottom:0}
.mini-lbl{font-size:10px;color:var(--text2);font-weight:500;min-width:58px}
.mini-val{
  font-size:10px;font-weight:600;color:var(--text);
  min-width:32px;text-align:right;font-variant-numeric:tabular-nums;
}
.mini-ctrl input[type=range]{flex:1}

/* ── SLIDER STYLING ── */
input[type=range]{
  height:4px;appearance:none;-webkit-appearance:none;
  background:#e5e5ea;border-radius:2px;outline:none;cursor:pointer;
}
input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none;width:12px;height:12px;border-radius:50%;
  background:white;cursor:pointer;
  box-shadow:0 1px 3px rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.06);
}
input[type=range]::-moz-range-thumb{
  width:12px;height:12px;border-radius:50%;
  background:white;cursor:pointer;border:none;
  box-shadow:0 1px 3px rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.06);
}

/* ── 3D CANVAS ── */
.cv-wrap{flex:1;position:relative;background:#f0f2f5}
#c3d{width:100%;height:100%}

.legend{
  position:absolute;bottom:10px;left:50%;transform:translateX(-50%);
  background:var(--card);border:1px solid var(--border);border-radius:8px;
  padding:5px 10px;display:flex;align-items:center;gap:6px;z-index:5;
}
.legend .lt{font-size:9px;color:var(--text2);font-weight:600}
.legend .ll{display:flex;justify-content:space-between;width:120px;font-size:7px;color:var(--text3);font-weight:500}

.seat-labels{
  position:absolute;top:10px;left:50%;transform:translateX(-50%);
  display:flex;gap:12px;z-index:5;
  background:var(--card);border:1px solid var(--border);border-radius:8px;
  padding:5px 12px;
}
.seat-label-item{display:flex;align-items:center;gap:4px;font-size:9px;font-weight:600;color:var(--text2)}
.seat-label-dot{width:8px;height:8px;border-radius:50%}

/* ── RIGHT PANEL ── */
.rp{
  width:320px;flex-shrink:0;
  overflow-y:auto;background:var(--surface);
  border-left:1px solid var(--border);padding:8px;
}
.rp::-webkit-scrollbar{width:3px}
.rp::-webkit-scrollbar-thumb{background:rgba(0,0,0,.1);border-radius:2px}

.rp-section{
  background:var(--card);border-radius:8px;
  padding:10px 12px;margin-bottom:8px;
  box-shadow:0 1px 3px rgba(0,0,0,.08);
}
.rp-section:last-child{margin-bottom:0}

.rp-title{
  font-size:9px;font-weight:700;color:var(--text3);
  text-transform:uppercase;letter-spacing:.7px;
  margin-bottom:8px;display:flex;align-items:center;gap:5px;
}
.rp-title i{font-size:8px}

.hm-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px}
.hm-cell{text-align:center}
.hm-cell canvas{display:block;margin:0 auto;border-radius:4px;border:1px solid var(--border);background:var(--bg)}
.hm-label{font-size:9px;font-weight:600;color:var(--text2);margin-top:3px}

/* ── BOTTOM STATS BAR ── */
.bottom-bar{
  height:40px;flex-shrink:0;
  background:var(--surface);
  border-top:1px solid var(--border);
  display:flex;align-items:center;justify-content:center;
  gap:20px;padding:0 20px;
}
.stat-item{
  font-size:11px;color:var(--text2);font-weight:500;
  display:flex;align-items:center;gap:5px;
}
.stat-item .s-label{font-weight:700}
.stat-item .s-val{
  font-family:'SF Mono','Cascadia Code',Consolas,monospace;
  font-variant-numeric:tabular-nums;font-size:10px;
}
.stat-sep{color:var(--text3);font-size:10px;opacity:.4}

/* ── LOADING ── */
.loading{
  position:fixed;inset:0;
  background:rgba(255,255,255,.92);backdrop-filter:blur(20px);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  z-index:100;transition:opacity .5s;
}
.loading.done{opacity:0;pointer-events:none}
.spinner{
  width:32px;height:32px;
  border:2.5px solid rgba(0,0,0,.06);border-top-color:var(--accent);
  border-radius:50%;animation:spin .7s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}
.load-msg{margin-top:12px;font-size:12px;color:var(--text2);font-weight:500}

.toast{
  position:fixed;bottom:56px;right:16px;
  background:var(--card);border:1px solid var(--border);border-radius:8px;
  padding:8px 16px;font-size:11px;color:var(--text);font-weight:500;
  z-index:50;opacity:0;transform:translateY(8px);
  transition:all .25s;pointer-events:none;
}
.toast.show{opacity:1;transform:translateY(0)}
</style>
</head>
<body>
<div class="app">
  <!-- HEADER -->
  <div class="hdr">
    <div class="hdr-left">
      <img src="keti.png" alt="KETI">
      <h1>Seat Analysis Dashboard</h1>
      <span class="hdr-tag">4-SEAT</span>
    </div>
    <div class="hdr-center" id="presetBtns">
      <button class="pb" onclick="goPreset('drive',this)">Drive</button>
      <button class="pb" onclick="goPreset('sport',this)">Sport</button>
      <button class="pb" onclick="goPreset('relax',this)">Relax</button>
      <button class="pb" onclick="goPreset('entry',this)">Entry</button>
      <button class="pb" onclick="goPreset('flat',this)">Flat</button>
      <button class="pb" onclick="goPreset('hold',this)">Hold</button>
    </div>
    <div class="hdr-right">
      <button class="toggle-btn" id="applyAllBtn" onclick="toggleApplyAll()">
        <i class="fas fa-link"></i> Apply All
      </button>
      <button class="export-btn" id="exportBtn" onclick="exportData()">
        <i class="fas fa-download"></i> Export
      </button>
    </div>
  </div>

  <div class="content">
    <!-- LEFT PANEL: Per-seat control cards -->
    <div class="lp">
      <div class="lp-hdr">
        <span class="lp-hdr-title"><i class="fas fa-sliders-h"></i> Seat Controls</span>
        <span class="lp-hdr-count">4 occupants</span>
      </div>
      <div id="leftPanel"></div>
    </div>

    <!-- 3D CANVAS -->
    <div class="cv-wrap">
      <div id="c3d"></div>
      <div class="seat-labels">
        <div class="seat-label-item"><div class="seat-label-dot" style="background:#2563eb"></div>FL</div>
        <div class="seat-label-item"><div class="seat-label-dot" style="background:#16a34a"></div>FR</div>
        <div class="seat-label-item"><div class="seat-label-dot" style="background:#ea580c"></div>RL</div>
        <div class="seat-label-item"><div class="seat-label-dot" style="background:#9333ea"></div>RR</div>
      </div>
      <div class="legend">
        <span class="lt">Pressure</span>
        <div>
          <canvas id="legCv" width="120" height="8" style="border-radius:4px;display:block"></canvas>
          <div class="ll"><span>0</span><span>50</span><span>100 kPa</span></div>
        </div>
      </div>
    </div>

    <!-- RIGHT PANEL: Comparison analytics -->
    <div class="rp">
      <div class="rp-section">
        <div class="rp-title"><i class="fas fa-chart-bar"></i> Average Pressure</div>
        <canvas id="barCv" width="280" height="130"></canvas>
      </div>
      <div class="rp-section">
        <div class="rp-title"><i class="fas fa-project-diagram"></i> Configuration Overlay</div>
        <canvas id="radarCv" width="280" height="280"></canvas>
      </div>
      <div class="rp-section">
        <div class="rp-title"><i class="fas fa-th"></i> Pressure Heatmaps</div>
        <div class="hm-grid">
          <div class="hm-cell">
            <canvas id="hm0" width="120" height="120"></canvas>
            <div class="hm-label" id="hmL0">FL Driver</div>
          </div>
          <div class="hm-cell">
            <canvas id="hm1" width="120" height="120"></canvas>
            <div class="hm-label" id="hmL1">FR Passenger</div>
          </div>
          <div class="hm-cell">
            <canvas id="hm2" width="120" height="120"></canvas>
            <div class="hm-label" id="hmL2">RL Rear-Left</div>
          </div>
          <div class="hm-cell">
            <canvas id="hm3" width="120" height="120"></canvas>
            <div class="hm-label" id="hmL3">RR Rear-Right</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- BOTTOM STATS BAR -->
  <div class="bottom-bar" id="bottomBar"></div>
</div>

<div class="loading" id="loader">
  <div class="spinner"></div>
  <div class="load-msg" id="lmsg">Loading 3D models...</div>
</div>
<div class="toast" id="toast"></div>

<script>
/* ===================================================
   CONFIG
   =================================================== */
const SEATS = [
  { id:0, name:'FL Driver',      label:'FL', pos:[-0.45, 0, -0.55], weight:75 },
  { id:1, name:'FR Passenger',   label:'FR', pos:[ 0.45, 0, -0.55], weight:65 },
  { id:2, name:'RL Rear-Left',   label:'RL', pos:[-0.45, 0,  0.55], weight:55 },
  { id:3, name:'RR Rear-Right',  label:'RR', pos:[ 0.45, 0,  0.55], weight:80 },
];

const COL = ['#2563eb', '#16a34a', '#ea580c', '#9333ea'];

const AXES = {
  slide:    { min:-100, max:100,  label:'Slide' },
  height:   { min:0,    max:100,  label:'Height' },
  tilt:     { min:-10,  max:10,   label:'Tilt' },
  recline:  { min:0,    max:40,   label:'Recline' },
  hrH:      { min:0,    max:100,  label:'HR Height' },
  hrT:      { min:-15,  max:15,   label:'HR Tilt' },
  bolster:  { min:0,    max:100,  label:'Bolster' },
  lumbar:   { min:0,    max:100,  label:'Lumbar' },
  bBolster: { min:0,    max:100,  label:'Bk Bolster' },
};

const PRESETS = {
  drive:  { slide:0,   height:20, tilt:2,   recline:8,  hrH:30,  hrT:-5,  bolster:20, lumbar:40, bBolster:15 },
  sport:  { slide:30,  height:0,  tilt:-3,  recline:3,  hrH:50,  hrT:-8,  bolster:80, lumbar:60, bBolster:70 },
  relax:  { slide:-40, height:40, tilt:5,   recline:35, hrH:60,  hrT:10,  bolster:10, lumbar:50, bBolster:10 },
  entry:  { slide:-80, height:0,  tilt:0,   recline:0,  hrH:0,   hrT:0,   bolster:0,  lumbar:0,  bBolster:0  },
  flat:   { slide:0,   height:50, tilt:8,   recline:40, hrH:100, hrT:15,  bolster:0,  lumbar:30, bBolster:0  },
  hold:   { slide:10,  height:10, tilt:-2,  recline:5,  hrH:40,  hrT:-3,  bolster:90, lumbar:70, bBolster:85 },
};

const ZERO = { slide:0, height:0, tilt:0, recline:0, hrH:0, hrT:0, bolster:0, lumbar:0, bBolster:0 };

const seats = SEATS.map(s => ({
  ...s,
  model: null, hl: null, bones: {}, rest: {},
  pos: { ...ZERO },
  target: null,
  wt: s.weight,
  grid: new Float32Array(256),
  avg: 0, peak: 0,
  hmC: null, hmB: null,
  collapsed: false,
}));

let cur = 0;
let applyAll = false;
let scene, camera, renderer, controls;
const clock = new THREE.Clock();

/* ===================================================
   THREE.JS SCENE INIT
   =================================================== */
function initScene() {
  const el = document.getElementById('c3d');
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f2f5);

  camera = new THREE.PerspectiveCamera(42, el.clientWidth / el.clientHeight, 0.01, 100);
  camera.position.set(2, 2.5, 2.8);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(el.clientWidth, el.clientHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.8;
  el.appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.target.set(0, 0.25, 0);
  controls.minDistance = 0.5;
  controls.maxDistance = 10;
  controls.maxPolarAngle = Math.PI * 0.85;

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 1.2));

  const keyLight = new THREE.DirectionalLight(0xffffff, 2.2);
  keyLight.position.set(2, 8, 3);
  keyLight.castShadow = true;
  keyLight.shadow.mapSize.set(2048, 2048);
  keyLight.shadow.camera.near = 0.1;
  keyLight.shadow.camera.far = 20;
  keyLight.shadow.camera.left = -3;
  keyLight.shadow.camera.right = 3;
  keyLight.shadow.camera.top = 3;
  keyLight.shadow.camera.bottom = -3;
  keyLight.shadow.bias = -0.001;
  scene.add(keyLight);

  scene.add(new THREE.DirectionalLight(0xc8d0ff, 0.8).translateX(-4).translateY(5).translateZ(-2));
  scene.add(new THREE.DirectionalLight(0xffffff, 0.5).translateZ(-6).translateY(2));
  scene.add(new THREE.HemisphereLight(0xffffff, 0xe8e8ea, 0.6));

  // Ground
  const grid = new THREE.GridHelper(5, 24, 0xccccce, 0xdddddf);
  grid.material.opacity = 0.4;
  grid.material.transparent = true;
  scene.add(grid);

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(10, 10),
    new THREE.MeshStandardMaterial({ color: 0xe8e8ea, roughness: 0.85 })
  );
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -0.005;
  floor.receiveShadow = true;
  scene.add(floor);

  buildCar();
  loadGLB();

  window.addEventListener('resize', () => {
    camera.aspect = el.clientWidth / el.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(el.clientWidth, el.clientHeight);
  });

  // Raycaster for seat selection via click
  const rc = new THREE.Raycaster();
  const v2 = new THREE.Vector2();
  renderer.domElement.addEventListener('click', e => {
    const r = renderer.domElement.getBoundingClientRect();
    v2.x = ((e.clientX - r.left) / r.width) * 2 - 1;
    v2.y = -((e.clientY - r.top) / r.height) * 2 + 1;
    rc.setFromCamera(v2, camera);
    for (let i = 0; i < seats.length; i++) {
      if (seats[i].model && rc.intersectObject(seats[i].model, true).length) {
        sel(i);
        break;
      }
    }
  });
}

/* ===================================================
   CAR OUTLINE
   =================================================== */
function buildCar() {
  const s = new THREE.Shape();
  const W = 0.8, FL = -0.95, RL = 0.9, R = 0.2;
  s.moveTo(-W + R, FL);
  s.lineTo(W - R, FL);
  s.quadraticCurveTo(W, FL, W, FL + R);
  s.lineTo(W, RL - R);
  s.quadraticCurveTo(W, RL, W - R, RL);
  s.lineTo(-W + R, RL);
  s.quadraticCurveTo(-W, RL, -W, RL - R);
  s.lineTo(-W, FL + R);
  s.quadraticCurveTo(-W, FL, -W + R, FL);

  const m = new THREE.Mesh(
    new THREE.ShapeGeometry(s),
    new THREE.MeshStandardMaterial({ color: 0xc0c0c2, transparent: true, opacity: 0.18, roughness: 0.8, side: THREE.DoubleSide })
  );
  m.rotation.x = -Math.PI / 2;
  m.position.y = 0.002;
  scene.add(m);

  // Front arrow indicator
  const a = new THREE.Shape();
  a.moveTo(-0.1, -1.02);
  a.lineTo(0, -1.14);
  a.lineTo(0.1, -1.02);
  const am = new THREE.Mesh(
    new THREE.ShapeGeometry(a),
    new THREE.MeshBasicMaterial({ color: 0x2563eb, transparent: true, opacity: 0.35, side: THREE.DoubleSide })
  );
  am.rotation.x = -Math.PI / 2;
  am.position.y = 0.004;
  scene.add(am);
}

/* ===================================================
   LOAD GLB MODELS
   =================================================== */
function loadGLB() {
  const loader = new THREE.GLTFLoader();
  let cnt = 0;

  seats.forEach((seat, i) => {
    loader.load('models/car-seat-rigged-v2.glb', gltf => {
      const model = gltf.scene;
      const box = new THREE.Box3().setFromObject(model);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const sc = 0.8 / Math.max(size.x, size.y, size.z);
      model.scale.setScalar(sc);
      model.position.set(
        seat.pos[0] - center.x * sc,
        seat.pos[1] - box.min.y * sc,
        seat.pos[2] - center.z * sc
      );

      const frameParts = new Set(['01 Base', '02 Base rim', '03 Base controls']);
      const sideParts = new Set(['05 Bottom sides', '07 Seat back sides']);

      model.traverse(c => {
        if (c.isMesh) {
          c.castShadow = true;
          c.receiveShadow = true;
          const n = c.name || (c.parent && c.parent.name) || '';
          let col = 0x2a2a2e, ro = 0.55, me = 0.04;
          if (frameParts.has(n)) { col = 0x18181c; ro = 0.25; me = 0.65; }
          else if (sideParts.has(n)) { col = 0x353538; ro = 0.48; me = 0.05; }
          if (c.material) {
            c.material.color.setHex(col);
            c.material.roughness = ro;
            c.material.metalness = me;
            c.material.needsUpdate = true;
          }
          if (c.isSkinnedMesh && c.skeleton) {
            c.skeleton.bones.forEach(b => { if (!seat.bones[b.name]) seat.bones[b.name] = b; });
          }
        }
        if (c.isBone && !seat.bones[c.name]) seat.bones[c.name] = c;
      });

      // Store rest pose
      Object.entries(seat.bones).forEach(([n, b]) => {
        seat.rest[n] = {
          px: b.position.x, py: b.position.y, pz: b.position.z,
          rx: b.rotation.x, ry: b.rotation.y, rz: b.rotation.z,
        };
      });

      scene.add(model);
      seat.model = model;

      // Selection ring
      const ring = new THREE.Mesh(
        new THREE.RingGeometry(0.28, 0.31, 32),
        new THREE.MeshBasicMaterial({ color: new THREE.Color(COL[i]), transparent: true, opacity: 0, side: THREE.DoubleSide })
      );
      ring.rotation.x = -Math.PI / 2;
      ring.position.set(seat.pos[0], 0.008, seat.pos[2]);
      scene.add(ring);
      seat.hl = ring;

      // Pressure overlays on model
      seat.hmC = mkOv(model, 0.22, 0.18, { rx: -Math.PI / 2, y: 1.15, z: -0.45 });
      seat.hmB = mkOv(model, 0.18, 0.26, { rx: -1.1, y: 2.3, z: -1.35 });

      cnt++;
      document.getElementById('lmsg').textContent = 'Loading model ' + cnt + ' / 4...';
      if (cnt === 4) {
        hilite();
        document.getElementById('loader').classList.add('done');
        toast('All 4 seat models loaded');
      }
    });
  });
}

function mkOv(parent, w, h, p) {
  const cv = document.createElement('canvas');
  cv.width = 64; cv.height = 64;
  const tex = new THREE.CanvasTexture(cv);
  tex.minFilter = THREE.LinearFilter;
  const mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(w, h),
    new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.6, side: THREE.DoubleSide, depthWrite: false })
  );
  mesh.rotation.x = p.rx || 0;
  mesh.position.set(p.x || 0, p.y || 0, p.z || 0);
  parent.add(mesh);
  return { cv, tex };
}

function hilite() {
  seats.forEach((s, i) => {
    const on = (i === cur);
    if (s.hl) s.hl.material.opacity = on ? 0.65 : 0.1;
    if (s.model) s.model.traverse(c => {
      if (c.isMesh && c.material && c.material.isMeshStandardMaterial) {
        c.material.emissive.setHex(on ? parseInt(COL[i].slice(1), 16) : 0);
        c.material.emissiveIntensity = on ? 0.18 : 0;
      }
    });
  });
}

/* ===================================================
   PRESSURE SIMULATION
   =================================================== */
function g2d(x, y, sx, sy) {
  return Math.exp(-(x * x) / (2 * sx * sx) - (y * y) / (2 * sy * sy));
}

function simPress(s, t) {
  const w = s.wt / 80;
  const off = s.id * 1.7;
  let sum = 0, mx = 0, cnt = 0;
  const bolF = s.pos.bolster / 100 * 0.15;

  for (let y = 0; y < 16; y++) {
    for (let x = 0; x < 16; x++) {
      const nx = (x / 15) * 2 - 1;
      const ny = (y / 15) * 2 - 1;
      let v = (
        g2d(nx + 0.35 - bolF, ny - 0.1, 0.28, 0.32) +
        g2d(nx - 0.35 + bolF, ny - 0.1, 0.28, 0.32) +
        g2d(nx + 0.3 - bolF, ny + 0.25, 0.22, 0.4) * 0.35 +
        g2d(nx - 0.3 + bolF, ny + 0.25, 0.22, 0.4) * 0.35
      ) * w;
      v += Math.sin((t + off) * 0.3) * 0.01 + (Math.random() - 0.5) * 0.005;
      v = Math.max(0, Math.min(1, v));
      s.grid[y * 16 + x] = v;
      if (v > 0.01) { sum += v; cnt++; mx = Math.max(mx, v); }
    }
  }
  s.avg = cnt > 0 ? (sum / cnt * 100) : 0;
  s.peak = mx * 100;
}

function updOv(s) {
  [s.hmC, s.hmB].forEach(ov => {
    if (!ov) return;
    const ctx = ov.cv.getContext('2d');
    ctx.clearRect(0, 0, 64, 64);
    if (s.wt < 1) { ov.tex.needsUpdate = true; return; }
    for (let y = 0; y < 16; y++) {
      for (let x = 0; x < 16; x++) {
        const v = s.grid[y * 16 + x];
        if (v > 0.02) {
          ctx.fillStyle = pRGBA(v);
          ctx.fillRect(x * 4, y * 4, 4, 4);
        }
      }
    }
    ov.tex.needsUpdate = true;
  });
}

/* ===================================================
   9-AXIS BONE CONTROL
   =================================================== */
function setPose(seatIdx, axis, val) {
  seats[seatIdx].pos[axis] = val;
  applyBone(seats[seatIdx], axis, val);

  if (applyAll) {
    seats.forEach((s, i) => {
      if (i !== seatIdx) {
        s.pos[axis] = val;
        applyBone(s, axis, val);
      }
    });
    renderCards();
  }
  syncSliders();
}

function applyBone(s, axis, val) {
  const R = s.rest, B = s.bones, d = THREE.MathUtils.degToRad;
  switch (axis) {
    case 'slide':
      if (B.Slide && R.Slide) B.Slide.position.z = R.Slide.pz - (val / 100) * 0.5;
      break;
    case 'height':
      if (B.Cushion && R.Cushion) B.Cushion.position.y = R.Cushion.py + (val / 100) * 0.3;
      break;
    case 'tilt':
      if (B.Cushion && R.Cushion) B.Cushion.rotation.x = R.Cushion.rx + d(val);
      break;
    case 'recline':
      if (B.Backrest && R.Backrest) B.Backrest.rotation.x = R.Backrest.rx + d(val);
      break;
    case 'hrH':
      if (B.Headrest && R.Headrest) B.Headrest.position.y = R.Headrest.py + (val / 100) * 0.5;
      break;
    case 'hrT':
      if (B.Headrest && R.Headrest) B.Headrest.rotation.x = R.Headrest.rx + d(val);
      break;
    case 'bolster':
      if (B.BolsterL && R.BolsterL) B.BolsterL.position.x = R.BolsterL.px + (val / 100) * 0.15;
      if (B.BolsterR && R.BolsterR) B.BolsterR.position.x = R.BolsterR.px - (val / 100) * 0.15;
      break;
    case 'lumbar':
      if (B.Lumbar && R.Lumbar) B.Lumbar.position.z = R.Lumbar.pz - (val / 100) * 0.3;
      break;
    case 'bBolster':
      if (B.BackBolsterL && R.BackBolsterL) B.BackBolsterL.position.x = R.BackBolsterL.px + (val / 100) * 0.12;
      if (B.BackBolsterR && R.BackBolsterR) B.BackBolsterR.position.x = R.BackBolsterR.px - (val / 100) * 0.12;
      break;
  }
}

function animTargets(dt) {
  seats.forEach(s => {
    if (!s.target) return;
    let done = true;
    Object.keys(AXES).forEach(k => {
      const diff = s.target[k] - s.pos[k];
      if (Math.abs(diff) > 0.3) {
        s.pos[k] += diff * dt * 5;
        done = false;
      } else {
        s.pos[k] = s.target[k];
      }
      applyBone(s, k, s.pos[k]);
    });
    if (done) s.target = null;
  });
}

function goPreset(name, btn) {
  document.getElementById('presetBtns').querySelectorAll('.pb').forEach(b => b.classList.remove('on'));
  btn.classList.add('on');
  if (applyAll) {
    seats.forEach(s => { s.target = { ...PRESETS[name] }; });
  } else {
    seats[cur].target = { ...PRESETS[name] };
  }
}

/* ===================================================
   APPLY ALL TOGGLE & EXPORT
   =================================================== */
function toggleApplyAll() {
  applyAll = !applyAll;
  document.getElementById('applyAllBtn').classList.toggle('on', applyAll);
  toast(applyAll ? 'Apply All enabled' : 'Apply All disabled');
}

function exportData() {
  let text = '=== Seat Analysis Export ===\n';
  text += 'Date: ' + new Date().toISOString() + '\n';
  text += 'Seats: ' + seats.length + '\n\n';

  seats.forEach((s, i) => {
    if (!s.model) return;
    text += '--- ' + SEATS[i].name + ' (' + s.wt + ' kg) ---\n';
    text += 'Position:\n';
    Object.keys(AXES).forEach(k => {
      const unit = (k === 'tilt' || k === 'recline' || k === 'hrT') ? '\u00b0' :
                   (k === 'bolster' || k === 'lumbar' || k === 'bBolster') ? '%' : '';
      text += '  ' + AXES[k].label.padEnd(12) + ': ' + (Math.round(s.pos[k] * 10) / 10) + unit + '\n';
    });
    text += 'Pressure:\n';
    text += '  Average : ' + s.avg.toFixed(1) + '%\n';
    text += '  Peak    : ' + s.peak.toFixed(1) + '%\n';
    text += '\n';
  });

  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('exportBtn');
    btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
    setTimeout(() => { btn.innerHTML = '<i class="fas fa-download"></i> Export'; }, 1500);
  });
}

/* ===================================================
   UI: LEFT PANEL CARD RENDERING
   =================================================== */
function renderCards() {
  const panel = document.getElementById('leftPanel');
  panel.innerHTML = '';

  seats.forEach((s, i) => {
    const card = document.createElement('div');
    card.className = 'seat-card' + (i === cur ? ' sel' : '');
    card.style.borderLeftColor = (i === cur) ? COL[i] : 'transparent';

    const axisKeys = Object.keys(AXES);

    // Build Base sliders (slide, height, tilt)
    let baseHTML = '';
    ['slide', 'height', 'tilt'].forEach(k => {
      const ax = AXES[k];
      const unit = (k === 'tilt') ? '\u00b0' : '';
      baseHTML += buildSliderRow(i, k, ax, s.pos[k], unit);
    });

    // Build Back sliders (recline, hrH, hrT)
    let backHTML = '';
    ['recline', 'hrH', 'hrT'].forEach(k => {
      const ax = AXES[k];
      const unit = (k === 'recline' || k === 'hrT') ? '\u00b0' : '';
      backHTML += buildSliderRow(i, k, ax, s.pos[k], unit);
    });

    // Build Support sliders (bolster, lumbar, bBolster)
    let supportHTML = '';
    ['bolster', 'lumbar', 'bBolster'].forEach(k => {
      const ax = AXES[k];
      supportHTML += buildSliderRow(i, k, ax, s.pos[k], '%');
    });

    card.innerHTML =
      '<div class="card-hdr" onclick="toggleCard(' + i + ')">' +
        '<div class="card-hdr-left">' +
          '<div class="card-dot" style="background:' + COL[i] + '"></div>' +
          '<span class="card-name">' + SEATS[i].name + '</span>' +
          '<span class="card-wt" id="cwt_' + i + '">' + s.wt + ' kg</span>' +
        '</div>' +
        '<i class="fas fa-chevron-down card-chevron' + (s.collapsed ? ' collapsed' : '') + '"></i>' +
      '</div>' +
      '<div class="card-body' + (s.collapsed ? ' collapsed' : '') + '">' +
        '<div class="wt-row">' +
          '<span class="wt-label">Weight</span>' +
          '<input type="range" class="wt-slider" min="0" max="130" value="' + s.wt + '" data-seat="' + i + '" oninput="setWt(+this.dataset.seat,+this.value)">' +
          '<span class="wt-val" id="wv_' + i + '">' + s.wt + ' kg</span>' +
        '</div>' +
        '<div class="card-divider"></div>' +
        '<div class="slider-sec-title">Base</div>' +
        baseHTML +
        '<div class="slider-sec-title">Back</div>' +
        backHTML +
        '<div class="slider-sec-title">Support</div>' +
        supportHTML +
      '</div>';

    panel.appendChild(card);
  });
}

function buildSliderRow(seatIdx, key, ax, val, unit) {
  const rounded = Math.round(val * 10) / 10;
  return '<div class="mini-ctrl">' +
    '<span class="mini-lbl">' + ax.label + '</span>' +
    '<input type="range" min="' + ax.min + '" max="' + ax.max + '" value="' + rounded + '" ' +
      'data-seat="' + seatIdx + '" data-axis="' + key + '" oninput="onSlider(this)">' +
    '<span class="mini-val" id="cv_' + seatIdx + '_' + key + '">' + Math.round(val) + unit + '</span>' +
    '</div>';
}

function onSlider(el) {
  const si = +el.dataset.seat;
  const axis = el.dataset.axis;
  const val = +el.value;
  setPose(si, axis, val);
}

function toggleCard(i) {
  if (cur !== i) { sel(i); return; }
  seats[i].collapsed = !seats[i].collapsed;
  renderCards();
}

function sel(i) {
  cur = i;
  hilite();
  renderCards();
  syncSliders();
}

function syncSliders() {
  seats.forEach((s, i) => {
    Object.keys(AXES).forEach(k => {
      const el = document.getElementById('cv_' + i + '_' + k);
      if (!el) return;
      const unit = (k === 'tilt' || k === 'recline' || k === 'hrT') ? '\u00b0' :
                   (k === 'bolster' || k === 'lumbar' || k === 'bBolster') ? '%' : '';
      el.textContent = Math.round(s.pos[k]) + unit;
    });
  });
}

function setWt(i, w) {
  seats[i].wt = w;
  const el = document.getElementById('wv_' + i);
  if (el) el.textContent = w + ' kg';
  const el2 = document.getElementById('cwt_' + i);
  if (el2) el2.textContent = w + ' kg';
}

/* ===================================================
   RIGHT PANEL: RADAR / SPIDER CHART
   =================================================== */
function drawRadar() {
  const cv = document.getElementById('radarCv');
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  const cx = W / 2, cy = H / 2 - 6;
  const R = Math.min(cx, cy) - 32;
  ctx.clearRect(0, 0, W, H);

  const axisKeys = Object.keys(AXES);
  const N = axisKeys.length;

  // Draw concentric grid polygons with scale labels
  for (let r = 0.2; r <= 1.001; r += 0.2) {
    ctx.beginPath();
    for (let i = 0; i <= N; i++) {
      const a = (i % N) * 2 * Math.PI / N - Math.PI / 2;
      const x = cx + R * r * Math.cos(a);
      const y = cy + R * r * Math.sin(a);
      (i === 0) ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.strokeStyle = (Math.abs(r - 1) < 0.01) ? 'rgba(0,0,0,.12)' : 'rgba(0,0,0,.06)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Scale percentage label on first axis
    if (r < 1.001) {
      const a0 = -Math.PI / 2;
      const lx = cx + R * r * Math.cos(a0) + 8;
      const ly = cy + R * r * Math.sin(a0) - 2;
      ctx.fillStyle = '#9a9fb0';
      ctx.font = '8px Inter';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(Math.round(r * 100) + '%', lx, ly);
    }
  }

  // Draw axis lines and labels
  axisKeys.forEach((key, i) => {
    const a = i * 2 * Math.PI / N - Math.PI / 2;
    const x = cx + R * Math.cos(a);
    const y = cy + R * Math.sin(a);

    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x, y);
    ctx.strokeStyle = 'rgba(0,0,0,.08)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Axis label
    const lx = cx + (R + 20) * Math.cos(a);
    const ly = cy + (R + 20) * Math.sin(a);
    ctx.fillStyle = '#5a6070';
    ctx.font = '10px Inter';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(AXES[key].label, lx, ly);
  });

  // Draw each seat's polygon
  seats.forEach((s, si) => {
    if (!s.model) return;
    ctx.beginPath();
    axisKeys.forEach((key, i) => {
      const ax = AXES[key];
      const norm = Math.max(0, Math.min(1, (s.pos[key] - ax.min) / (ax.max - ax.min)));
      const a = i * 2 * Math.PI / N - Math.PI / 2;
      const x = cx + R * norm * Math.cos(a);
      const y = cy + R * norm * Math.sin(a);
      (i === 0) ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.closePath();
    ctx.fillStyle = COL[si] + '30';
    ctx.fill();
    ctx.strokeStyle = COL[si];
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw vertex dots
    axisKeys.forEach((key, i) => {
      const ax = AXES[key];
      const norm = Math.max(0, Math.min(1, (s.pos[key] - ax.min) / (ax.max - ax.min)));
      const a = i * 2 * Math.PI / N - Math.PI / 2;
      const x = cx + R * norm * Math.cos(a);
      const y = cy + R * norm * Math.sin(a);
      ctx.beginPath();
      ctx.arc(x, y, 2.5, 0, Math.PI * 2);
      ctx.fillStyle = COL[si];
      ctx.fill();
    });
  });

  // Legend row at bottom
  const ly = H - 10;
  ctx.font = '9px Inter';
  ctx.textBaseline = 'middle';
  let lx = cx - SEATS.length * 32 / 2;
  SEATS.forEach((st, i) => {
    ctx.fillStyle = COL[i];
    ctx.fillRect(lx, ly - 4, 8, 8);
    ctx.fillStyle = '#5a6070';
    ctx.textAlign = 'left';
    ctx.fillText(st.label, lx + 11, ly);
    lx += 38;
  });
}

/* ===================================================
   RIGHT PANEL: HORIZONTAL BAR CHART
   =================================================== */
function drawBars() {
  const cv = document.getElementById('barCv');
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  ctx.clearRect(0, 0, W, H);

  const pad = 12;
  const barH = 20;
  const gap = 8;
  const labelW = 28;
  const valW = 52;
  const maxBarW = W - pad * 2 - labelW - valW;

  seats.forEach((s, i) => {
    if (!s.model) return;
    const y = pad + i * (barH + gap);
    const avg = s.avg;
    const peak = s.peak;
    const w = (avg / 100) * maxBarW;
    const pw = (peak / 100) * maxBarW;

    // Seat label
    ctx.fillStyle = COL[i];
    ctx.font = '700 11px Inter';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(SEATS[i].label, pad, y + barH / 2);

    // Bar track background
    ctx.fillStyle = 'rgba(0,0,0,.03)';
    ctx.beginPath();
    ctx.roundRect(pad + labelW, y, maxBarW, barH, 3);
    ctx.fill();

    // Peak marker line
    if (peak > 0) {
      ctx.strokeStyle = COL[i] + '40';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(pad + labelW + pw, y);
      ctx.lineTo(pad + labelW + pw, y + barH);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Average bar fill
    ctx.fillStyle = COL[i];
    ctx.globalAlpha = 0.82;
    ctx.beginPath();
    ctx.roundRect(pad + labelW, y, Math.max(w, 2), barH, 3);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Value text
    ctx.fillStyle = '#1a1a2e';
    ctx.font = '700 10px Inter';
    ctx.textAlign = 'left';
    ctx.fillText(avg.toFixed(1) + '%', pad + labelW + maxBarW + 6, y + barH / 2);
  });
}

/* ===================================================
   RIGHT PANEL: 4-SEAT HEATMAP GRID
   =================================================== */
function drawAllHeatmaps() {
  seats.forEach((s, i) => {
    const cv = document.getElementById('hm' + i);
    if (!cv) return;
    const ctx = cv.getContext('2d');
    const W = cv.width, H = cv.height;
    ctx.clearRect(0, 0, W, H);
    if (!s.model) return;

    const cellW = W / 16;
    const cellH = H / 16;

    for (let y = 0; y < 16; y++) {
      for (let x = 0; x < 16; x++) {
        const v = s.grid[y * 16 + x];
        if (v > 0.01) {
          ctx.fillStyle = pRGBA(v);
          ctx.fillRect(x * cellW, y * cellH, cellW + 0.5, cellH + 0.5);
        }
      }
    }
  });
}

/* ===================================================
   BOTTOM STATS BAR
   =================================================== */
function updateBottomBar() {
  const bar = document.getElementById('bottomBar');
  let html = '';
  seats.forEach((s, i) => {
    if (i > 0) html += '<span class="stat-sep">|</span>';
    html +=
      '<span class="stat-item">' +
        '<span class="s-label" style="color:' + COL[i] + '">' + SEATS[i].label + ':</span>' +
        '<span class="s-val">Avg ' + s.avg.toFixed(1) + '%</span>' +
        '<span class="s-val">Peak ' + s.peak.toFixed(1) + '%</span>' +
      '</span>';
  });
  bar.innerHTML = html;
}

/* ===================================================
   COLOR UTILITIES
   =================================================== */
function pRGBA(t) {
  t = Math.max(0, Math.min(1, t));
  let r, g, b;
  if (t < 0.25) {
    const f = t / 0.25;
    r = 0; g = Math.round(f * 255); b = 255;
  } else if (t < 0.5) {
    const f = (t - 0.25) / 0.25;
    r = 0; g = 255; b = Math.round(255 * (1 - f));
  } else if (t < 0.75) {
    const f = (t - 0.5) / 0.25;
    r = Math.round(255 * f); g = 255; b = 0;
  } else {
    const f = (t - 0.75) / 0.25;
    r = 255; g = Math.round(255 * (1 - f)); b = 0;
  }
  return 'rgba(' + r + ',' + g + ',' + b + ',' + (0.3 + t * 0.7) + ')';
}

let tt;
function toast(m) {
  const t = document.getElementById('toast');
  t.textContent = m;
  t.classList.add('show');
  clearTimeout(tt);
  tt = setTimeout(() => t.classList.remove('show'), 2000);
}

function drawLeg() {
  const ctx = document.getElementById('legCv').getContext('2d');
  for (let x = 0; x < 120; x++) {
    ctx.fillStyle = pRGBA(x / 120);
    ctx.fillRect(x, 0, 1, 8);
  }
}

/* ===================================================
   ANIMATION LOOP
   =================================================== */
let lastUI = 0;

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.1);
  const t = clock.getElapsedTime();

  // Simulate pressure for all seats
  seats.forEach(s => { simPress(s, t); updOv(s); });

  // Animate preset transitions
  animTargets(dt);

  // Sync sliders if any seat is mid-animation
  let anyAnimating = false;
  seats.forEach(s => { if (s.target) anyAnimating = true; });
  if (anyAnimating) { syncSliders(); renderCards(); }

  // Periodic UI updates
  if (t - lastUI > 0.2) {
    updateBottomBar();
    lastUI = t;
  }

  controls.update();
  renderer.render(scene, camera);
}

/* ===================================================
   INIT
   =================================================== */
initScene();
drawLeg();
renderCards();
syncSliders();
animate();

setInterval(() => {
  drawRadar();
  drawBars();
  drawAllHeatmaps();
}, 500);
</script>
</body>
</html>
